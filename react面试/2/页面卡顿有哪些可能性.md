## react 中点击一个按钮，页面卡顿有哪些可能性？

1. 组件渲染问题：
   - 组件更新导致大量的不必要的重新渲染
     使用 React.memo（props 浅比较） 包含函数组件，防止不必要的渲染
2. 复杂的计算逻辑
   使用 useMemo 缓存函数计算结果
   使用 Web Workers，将复杂计算移到 Web Workers 中进行异步处理
3. 长时间运行的事件处理函数
   原因：事件处理函数中包含长时间运行的同步代码。

   - requestAnimationFrame :将代码分批执行
     requestAnimationFrame 虽然主要用于动画，但它的核心特点是与浏览器的重绘同步，这使得它在某些非动画任务（如分批处理大数据集）中也非常有用。其主要优势包括：
     与浏览器重绘同步：利用浏览器的刷新节奏，避免在主线程长时间阻塞，提供更平滑的用户体验。
     自动暂停：当页面不可见时，requestAnimationFrame 会自动暂停，从而节省资源。
   - setTimeout 将同步代码，异步分段执行

   ```js
   function load() {
     let total = 10000;
     let length = 20;
     let index = 0;
     let page = total / length;
     function loop(curTotal, currentIndex) {
       if (curTotal <= 0) {
         return false;
       }
       let count = Math.min(curTotal,length)
       setTimeout(()=>{
        for(let i = 0,i < count,i++){
          console.log(i)
        }

        loop(curTotal - count, curIndex + pageCount)
       },0)
     }
     loop(total,index)
   }

   ```

   ```js
   function longRunningTask() {
     const totalIterations = 10000;
     const batchSize = 100; // 每次执行的操作数
     let currentIteration = 0;
     function processBatch() {
       const start = currentIteration;
       const end = Math.min(currentIteration + batchSize, totalIterations);

       for (let i = start; i < end; i++) {
         // 这里是要执行的操作
         console.log(`Processing iteration ${i + 1}`);
       }

       currentIteration += batchSize;

       if (currentIteration < totalIterations) {
         // 使用 requestAnimationFrame 分段执行下一批任务
         requestAnimationFrame(processBatch);
         // 使用 setTimeout 分段执行下一批任务
         //setTimeout(processBatch, 0);
       } else {
         console.log("Task completed");
       }
     }
     requestAnimationFrame(processBatch);
     // 开始执行
     //processBatch();
     // 调用函数
     longRunningTask();
   }
   ```

4. 大数据列表渲染
   列表虚拟化：使用 react-window 或 react-virtualized 进行列表虚拟化。

```jsx
import { FixedSizeList as List } from "react-window";

const MyList = ({ items }) => (
  <List height={500} itemCount={items.length} itemSize={35} width={300}>
    {({ index, style }) => <div style={style}>{items[index]}</div>}
  </List>
);
```
